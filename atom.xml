<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spectop&#39;s</title>
  
  <subtitle>RMGL</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://spectop.github.io/"/>
  <updated>2019-03-01T09:44:22.431Z</updated>
  <id>https://spectop.github.io/</id>
  
  <author>
    <name>Spectop</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>痒痒鼠自动刷妖气封印</title>
    <link href="https://spectop.github.io/2019/02/18/onmyoji-support/"/>
    <id>https://spectop.github.io/2019/02/18/onmyoji-support/</id>
    <published>2019-02-18T14:10:07.000Z</published>
    <updated>2019-03-01T09:44:22.431Z</updated>
    
    <content type="html"><![CDATA[<p>之前在玩痒痒鼠的时候，苦于刷副本比较累，于是写了自动刷妖气封印的代码。现在对痒痒鼠兴致缺缺，在整理电脑文件的时候就把代码整理上传到了 <a href="https://github.com/spectop/spectop_others/tree/master/python/yysgo" target="_blank" rel="noopener">GitHub</a> 上了。这里记录一下整个代码的结构和思路备忘。</p><a id="more"></a><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>整个程序包含3个 Python 文件和两个目录，如下：</p><ul><li>pic  :  用于放置一些用来确定场景进行比较的图片</li><li>usr  :  用于放置用户名的截图</li><li>baseFunction.py  :  定义了一些鼠标的基本操作</li><li>order.py  :  定义了按钮位置、尺寸大小等信息；每个副本的操作流程在此</li><li>yysgo.py  :  程序入口</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol><li><p>在 usr 目录下添加一张游戏名称的截图（部分截图即可，需要 png 格式）。如下图 zhzz.png（我的游戏名称是“最后之作”） ：</p><p><img src="/2019/02/18/onmyoji-support/zhzz.png" alt="zhzz"></p></li><li><p>在命令行输入</p><p><code>python yysgo.py user_name what_to_do times code</code> </p></li></ol><ul><li><p>user_name : 你放在 usr 目录下的截图文件名，不包含格式后缀，如上面的应该是 zhzz</p></li><li><p>What_to_do : 需要刷的副本，使用拼音首字母。如鬼使黑的话就是 gsh</p></li><li><p>times : 需要刷的次数</p></li><li><p>code : 0~7 的数字，内容如下：</p>     <table>     <tbody>     <tr>     <td style="width: 81px;" rowspan="2">&nbsp;</td>     <td style="width: 30px;" colspan="2">&nbsp; 接受房主</td>     <td style="width: 30px;" colspan="2">不当房主&nbsp;&nbsp;</td>     </tr>     <tr>     <td style="width: 15px;">有活动</td>     <td style="width: 15px;">无活动</td>     <td style="width: 15px;">有活动</td>     <td style="width: 15px;">无活动</td>     </tr>     <tr>     <td style="width: 81px;">&nbsp;接受邀请</td>     <td style="width: 15px;">&nbsp;7</td>     <td style="width: 15px;">6&nbsp;</td>     <td style="width: 15px;">5&nbsp;</td>     <td style="width: 15px;">4&nbsp;</td>     </tr>     <tr>     <td style="width: 81px;">&nbsp;不接受邀请</td>     <td style="width: 15px;">&nbsp;3</td>     <td style="width: 15px;">2&nbsp;</td>     <td style="width: 15px;">1&nbsp;</td>     <td style="width: 15px;">0&nbsp;</td>     </tr>     </tbody>     </table>     </li></ul><p>   ​    （其中的活动指的是痒痒鼠经常会有的一些鬼王活动，使得原本的「妖气封印」按钮下移一格）</p><p>   eg. <code>python yysgo.py zhzz gsh 100 6</code> 表示刷100次鬼使黑，接受悬赏封印邀请，若原房主退出则接受房主，没有特殊活动</p><h1 id="程序内容"><a href="#程序内容" class="headerlink" title="程序内容"></a>程序内容</h1><p>整个程序的原理比较简单，就是模拟平时手动刷副本时的操作而已。</p><div id="flowchart-0" class="flow-chart"></div><h2 id="baseFunction-py"><a href="#baseFunction-py" class="headerlink" title="baseFunction.py"></a>baseFunction.py</h2><p>baseFunction.py 内定义了一些基本的鼠标操作，如：</p><ul><li><strong>点击</strong> ：click(area, delay=0.5)<ul><li>area ：点击区域</li><li>delay ：延时最大值（后面的 delay 皆是如此）</li></ul></li><li><strong>拖拽</strong> ：drag(begin_area, end_area, delay=0.5, duraction=0.5)<ul><li>begin_area ：开始区域</li><li>end_eare ：结束区域</li><li>duraction ：拖拽最大时长</li></ul></li><li><strong>寻找图片</strong> ：find_picture(file_location)，返回 T/F<ul><li>file_location ：图片文件文字</li></ul></li></ul><p>以及基于这些操作的一些其他操作，如：</p><ul><li><strong>滚动</strong> ：roll(block_nums, area, block_height, eps=2, delay=0.5, duraction=0.5)<ul><li>block_nums ：滚动格数，负数为从长往下拖拽一格，正数为从下往上</li><li>area ：可以操作的列表区域</li><li>block_height ：一格的高度</li><li>eps ：误差</li></ul></li><li><strong>检测邀请</strong> ：check_invatation(operation, pic, button_accept, button_decline)<ul><li>operation ：收到悬赏封印邀请的操作</li><li>pic ：悬赏封印邀请的截图位置</li><li>button_accept ：「接受」按钮区域</li><li>button_decline ：「拒接」按钮区域</li></ul></li><li><strong>检测房主</strong> ：check_roomowner(pic)，返回 T/F<ul><li>pic ：成为房主时的标志图片（默认使用亮起的「开始战斗」按钮的截图作为已经成为房主的依据）</li></ul></li><li><strong>检测等待状态</strong> ：check_searching(pic, button)，无返回值，若不在匹配中，则点击「开始匹配」继续<ul><li>pic ：正在匹配的标志图片（默认使用亮起的「取消匹配」按钮的截图作为正在匹配中的依据）</li></ul></li><li><strong>等待</strong> ：waiting(symbol, invatation_pic, invatation_operation, roomowner_pic, searching_pic, button_set)<ul><li>symbol ：进入战斗（「准备」按钮亮起）的标志图片</li><li>*_pic ：上面三个检测的图片位置</li><li>invatation_operation ：收到悬赏封印邀请的操作</li><li>button_set ：按钮的位置的 list，[button_accept, button_decline, button_search]</li></ul></li></ul><p><strong>注意</strong> ：</p><ul><li>图片的检测使用最原始的逐像素比对，因此若图片大小不对也会导致无法检测，这一点有兴趣的同志可以改进一下。在自行截图时要注意游戏的某些位置是动态的，或者的动态的底层上加一层半透明图片，这会导致图片检测失效。</li><li>这里与时间相关的参数都是时间的最大值，程序执行时等待的对应时间都是从0到该「最大值」的随机数，以避免防作弊检测</li><li>同理，这里所有的按钮的点击还有拖拽的操作，位置都是随机的。每一个 area（或 button） 都是 [[x1, y1], [x2, y2]] 的形式</li></ul><h2 id="order-py"><a href="#order-py" class="headerlink" title="order.py"></a>order.py</h2><p>order.py 定义了一些组合操作（即刷一个副本的完整操作，使用 baseFunction 的函数，也可以自行在此添加其他副本的操作），设置了一些有关按钮和相关检测区域位置坐标的参数。</p><h3 id="副本操作示例（部分内容省略）"><a href="#副本操作示例（部分内容省略）" class="headerlink" title="副本操作示例（部分内容省略）"></a>副本操作示例（部分内容省略）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">guishihei</span><span class="params">(count, invitation_op, roomowner_op, user_name, activities=False)</span>:</span></span><br><span class="line"><span class="comment"># count : 刷该副本的次数</span></span><br><span class="line"><span class="comment"># *_op, activities : 对应上面表格</span></span><br><span class="line"><span class="comment"># user_name : 用户名(与上文一致，即截图的文件名)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(count - index &gt; <span class="number">0</span>):</span><br><span class="line">pyautogui.moveTo(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0.3</span>) <span class="comment"># 为防止鼠标的遮挡，每次需要匹配图片之前，将鼠标移动到左上角，后面不再出现这行代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 执行副本组队的一连串操作</span></span><br><span class="line">baseFunction.waiting(get_start_symbol(user_name), PIC_INVATATION, invitation_op, PIC_ROOMOWNER, PIC_IS_SEARCHING, button_set) <span class="comment"># 若检测到 user_name.png 在屏幕中，则认为可以开始新一轮操作，否则继续等待</span></span><br><span class="line">baseFunction.click(get_button(TEAM)) <span class="comment"># 点击『组队』按钮</span></span><br><span class="line"><span class="keyword">if</span> activities:</span><br><span class="line">baseFunction.roll(<span class="number">1</span>, get_button(AREA[<span class="number">0</span>]), block_height)</span><br><span class="line">baseFunction.click(get_button(DEMON_SEAL)) <span class="comment"># 点击『妖气封印』按钮，若有特殊活动，将列表下滚一格再点击</span></span><br><span class="line">drag_area = [get_button(AREA[<span class="number">1</span>][<span class="number">0</span>]), get_button(AREA[<span class="number">1</span>][<span class="number">1</span>])] <span class="comment"># 计算拖动区域</span></span><br><span class="line">baseFunction.roll(<span class="number">8</span>, drag_area, block_height_l2) <span class="comment"># 下滚列表</span></span><br><span class="line">baseFunction.click(get_button(GUI_SHI_HEI)) <span class="comment"># 点击『鬼使黑』按钮</span></span><br><span class="line">baseFunction.click(get_button(MATCH)) <span class="comment"># 点击『自动匹配』</span></span><br><span class="line">interupt = baseFunction.waiting(PIC_READY, PIC_INVATATION, invitation_op, PIC_ROOMOWNER, PIC_IS_SEARCHING, button_set) <span class="comment"># 检测『准备』按钮是否出现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 特殊情况的处理</span></span><br><span class="line"><span class="keyword">if</span> interupt == <span class="number">1</span>: <span class="comment"># 1 表示成为房主了(waiting()函数会每隔一段时间检测悬赏封印邀请和房间状态，正常状态返回 0)</span></span><br><span class="line"><span class="keyword">if</span> roomowner_op:</span><br><span class="line">baseFunction.click(get_button(START)) <span class="comment"># 若接受成为房主，则点击『开始战斗』按钮开始</span></span><br><span class="line"><span class="keyword">if</span> baseFunction.waiting(PIC_ROOMOWNER, PIC_INVATATION, invitation_op, PIC_ROOMOWNER, PIC_IS_SEARCHING, button_set) == <span class="number">0</span>: <span class="comment"># 由于检测房主间隔时间较长，有可能执行到这里时其他玩家退出了，因此需要等待『开始战斗』按钮重新亮起</span></span><br><span class="line">baseFunction.click(get_button(START))</span><br><span class="line">baseFunction.waiting(PIC_READY, PIC_INVATATION, invitation_op, PIC_ROOMOWNER, PIC_IS_SEARCHING, button_set) <span class="comment"># 等待『准备』按钮</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">baseFunction.click(get_button(BACK)) <span class="comment"># 若不接受房主，左上角返回，开始下一轮</span></span><br><span class="line">countinue</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 到这里准备按钮亮起，玩家已经进入副本并可以开始战斗了</span></span><br><span class="line">baseFunction.click(get_button(PREPARE)) <span class="comment"># 点击『准备』按钮</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 战斗完成，点击任意位置退出</span></span><br><span class="line">baseFunction.waiting(PIC_FINISH, PIC_INVATATION, invitation_op, PIC_ROOMOWNER, PIC_IS_SEARCHING, button_set)</span><br><span class="line">baseFunction.click(get_button(FINISH))</span><br></pre></td></tr></table></figure><h3 id="部分参数设置-分辨率等参数不同，最好使用前重新测定坐标）"><a href="#部分参数设置-分辨率等参数不同，最好使用前重新测定坐标）" class="headerlink" title="部分参数设置(分辨率等参数不同，最好使用前重新测定坐标）"></a>部分参数设置(分辨率等参数不同，最好使用前重新测定坐标）</h3><ul><li>block_height_l1/l2 : 列表一格的高度，我在测量时 妖气封印的子列表(l2) 和其本身的列表(l1) 高度并不一样</li><li>BASE : 基准点，后面的所有坐标都是对此坐标的相对位置，采取窗口左上角坐标作为基准点</li><li>ACCEPT, DECLINE, BACK, START : （悬赏封印）接受/拒绝，返回，开始战斗 按钮的位置</li><li>MATCH, PREPARE, FINISH : 自动匹配，准备，完成（点击任意位置退出） 按钮的位置</li><li>TEAM, DEMON_SEAL : 组队（庭院界面），妖气封印 按钮的位置</li><li>AREA : 列表的区域，roll() 函数需要这个区域来确定拖动的界限，AREA[0]是点击组队后出现的列表(l1)，AREA[1]是妖气封印下的子列表(l2)</li><li>PIC_*, USER_BASE : 各种图片位置，用户名截图目录</li></ul><h2 id="yysgo-py"><a href="#yysgo-py" class="headerlink" title="yysgo.py"></a>yysgo.py</h2><p>程序入口，不用多说。</p><p>在 order.py 中添加新的操作后，需要在这里调用。</p><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><ul><li>图片检测的速度不够快，这有时会导致一些意料之外的事发生</li><li>逐一像素检测图片会导致以后若有改版，需要重新截图</li><li>order.py 中对特殊状况的处理似乎有一些错误，不过在实际使用中没有发生意外，就没有修改了<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始cond1=>condition: 处于主界面？cond2=>condition: 「准备」按钮亮起？cond3=>condition: 检测战斗是否完成cond4=>condition: 是否达到设定次数op1=>operation: 「组队」->「妖气封印」->「对应副本」->「自动匹配」op5=>operation: 「准备」op6=>operation: 空白处任意点击e=>end: 结束st->cond1cond1(yes)->op1cond1(no)->cond1op1->cond2cond2(yes)->op5cond2(no)->cond2op5->cond3cond3(yes)->op6cond3(no)->cond3op6(right)->cond4cond4(yes)->econd4(no)->cond1</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在玩痒痒鼠的时候，苦于刷副本比较累，于是写了自动刷妖气封印的代码。现在对痒痒鼠兴致缺缺，在整理电脑文件的时候就把代码整理上传到了 &lt;a href=&quot;https://github.com/spectop/spectop_others/tree/master/python/yysgo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt; 上了。这里记录一下整个代码的结构和思路备忘。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://spectop.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://spectop.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>使用 dlib 对人脸特征点标记</title>
    <link href="https://spectop.github.io/2018/02/24/face-landmark-with-dlib68/"/>
    <id>https://spectop.github.io/2018/02/24/face-landmark-with-dlib68/</id>
    <published>2018-02-24T05:01:01.000Z</published>
    <updated>2018-02-24T06:28:53.478Z</updated>
    
    <content type="html"><![CDATA[<p>我在做表情识别的时候，使用的是 CK/CK+ 的数据集，然而令人难受的是，我一直不知道如何去标记人脸特征点。因为数据集里面有标记好的 Landmarks，都放在里面了。所以我训练是直接用这个数据的，测试集其实也是从里面随机抽取的。</p><p>然而昨天在找资料的时候，我很敏感的发现了68这个数字。天哪，我怎么会忘记，这个就是 CK/CK+ 数据集里面标记点的个数啊！</p><p>于是，我开始了 dlib 的调试。</p><hr><a id="more"></a><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>话不多说，还是：</p><p>macOS + anaconda + Python2.7</p><h2 id="dlib-的安装："><a href="#dlib-的安装：" class="headerlink" title="dlib 的安装："></a>dlib 的安装：</h2><p>对于 Mac 用户，参见<a href="https://www.jianshu.com/p/3e0b7d1ddc56" target="_blank" rel="noopener">这一篇</a></p><p>其实我根本就是忘记了我在安装 face_recognition 时曾经在 Python3 的环境下安装过 dlib 了。<a href="https://spectop.github.io/2018/01/19/Face-Recognition/">看这里</a></p><h2 id="特征检测器"><a href="#特征检测器" class="headerlink" title="特征检测器"></a>特征检测器</h2><p>需要下载特征<a href="http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2" target="_blank" rel="noopener">检测器</a>，当然你也可以自己训练 (/滑稽)</p><p>下载后可以解压出一个 dat 文件，我们需要的就是这个。</p><hr><h1 id="检测人脸"><a href="#检测人脸" class="headerlink" title="检测人脸"></a>检测人脸</h1><p>之前就说过，dlib 也是可以检测人脸的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">detector = dlib.get_frontal_face_detector()</span><br><span class="line">faces = detector(img, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这样，faces 里面就存储了所有脸部区域的范围。</p><p>值得注意的是，faces[i] 是第 i 张脸，使用<code>.top()    .bottom()    .left()    .right()</code>四个函数得到具体的值</p><hr><h1 id="特征点标记"><a href="#特征点标记" class="headerlink" title="特征点标记"></a>特征点标记</h1><p>加载刚刚下载的文件来标记特征点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">landmark_predictor = dlib.shape_predictor(<span class="string">'./shape_predictor_68_face_landmarks.dat'</span>)</span><br><span class="line">shape = landmark_predictor(img,face_area)</span><br></pre></td></tr></table></figure><p>其中，shape 就保存了特征点的信息。</p><p>为了得到特征点的坐标，需要使用<code>.part()</code>函数，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x[i] = shape.part(i).x</span><br><span class="line">y[i] = shape.part(i).y</span><br></pre></td></tr></table></figure><p>特征点是有顺序的，如下图：</p><p><img src="/2018/02/24/face-landmark-with-dlib68/tzd_samp.png" alt=""></p><p>68个特征点的位置如下：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    IdxRange jaw;       // [<span class="number">0</span> , <span class="number">16</span>]</span><br><span class="line">    IdxRange rightBrow; // [<span class="number">17</span>, <span class="number">21</span>]</span><br><span class="line">    IdxRange leftBrow;  // [<span class="number">22</span>, <span class="number">26</span>]</span><br><span class="line">    IdxRange nose;      // [<span class="number">27</span>, <span class="number">35</span>]</span><br><span class="line">    IdxRange rightEye;  // [<span class="number">36</span>, <span class="number">41</span>]</span><br><span class="line">    IdxRange leftEye;   // [<span class="number">42</span>, <span class="number">47</span>]</span><br><span class="line">    IdxRange mouth;     // [<span class="number">48</span>, <span class="number">59</span>]</span><br><span class="line">    IdxRange mouth2;    // [<span class="number">60</span>, <span class="number">67</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> dlib</span><br><span class="line"></span><br><span class="line">detector = dlib.get_frontal_face_detector()</span><br><span class="line">landmark_predictor = dlib.shape_predictor(<span class="string">'./shape_predictor_68_face_landmarks.dat'</span>)</span><br><span class="line">img = cv2.imread(<span class="string">'./lyf2.png'</span>)</span><br><span class="line">faces = detector(img, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len(faces) &gt; <span class="number">0</span>):</span><br><span class="line">    <span class="keyword">for</span> k,d <span class="keyword">in</span> enumerate(faces):</span><br><span class="line">        <span class="comment"># cv2.rectangle(img,(d.left(),d.top()),(d.right(),d.bottom()),(255,255,255))</span></span><br><span class="line">        shape = landmark_predictor(img,d)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">68</span>):</span><br><span class="line">            img2 = cv2.circle(img, (shape.part(i).x, shape.part(i).y),<span class="number">5</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">-1</span>, <span class="number">8</span>)</span><br><span class="line">            img2 = cv2.putText(img,str(i),(shape.part(i).x,shape.part(i).y),cv2.FONT_HERSHEY_SIMPLEX,<span class="number">0.5</span>,(<span class="number">255</span>,<span class="number">2555</span>,<span class="number">255</span>))</span><br><span class="line">cv2.imshow(<span class="string">'Frame'</span>,img)</span><br><span class="line">cv2.imwrite(<span class="string">'./landmark.jpg'</span>, img2)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>效果如下：</p><table><tr><br><td><img src="/2018/02/24/face-landmark-with-dlib68/lyf2.png"></td><br><td><img src="/2018/02/24/face-landmark-with-dlib68/landmark.jpg"></td><br></tr></table><hr><p><strong>蛤</strong>，你问 Landmark 还可以用来干嘛？</p><p>当然是让美帝也感受一下<strong>膜法</strong>的力量！！！</p><table><tr><br><td><img src="/2018/02/24/face-landmark-with-dlib68/glassesssss_obm.jpg"></td><br><td><img src="/2018/02/24/face-landmark-with-dlib68/glassesssss_dt1.jpg"></td><br><td><img src="/2018/02/24/face-landmark-with-dlib68/glassesssss_ssl1.jpg"></td><br></tr></table><p>根据眼睛眉毛附近的点，来设计黑框眼镜的位置和大小。</p><p>代码很简单，我就不放了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在做表情识别的时候，使用的是 CK/CK+ 的数据集，然而令人难受的是，我一直不知道如何去标记人脸特征点。因为数据集里面有标记好的 Landmarks，都放在里面了。所以我训练是直接用这个数据的，测试集其实也是从里面随机抽取的。&lt;/p&gt;
&lt;p&gt;然而昨天在找资料的时候，我很敏感的发现了68这个数字。天哪，我怎么会忘记，这个就是 CK/CK+ 数据集里面标记点的个数啊！&lt;/p&gt;
&lt;p&gt;于是，我开始了 dlib 的调试。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://spectop.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://spectop.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="https://spectop.github.io/tags/Python/"/>
    
      <category term="人脸识别" scheme="https://spectop.github.io/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
      <category term="情感识别" scheme="https://spectop.github.io/tags/%E6%83%85%E6%84%9F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>使用 OpenCV 检测人脸</title>
    <link href="https://spectop.github.io/2018/02/24/Face-recog-with-opencv/"/>
    <id>https://spectop.github.io/2018/02/24/Face-recog-with-opencv/</id>
    <published>2018-02-24T02:56:47.000Z</published>
    <updated>2018-02-24T06:23:27.887Z</updated>
    
    <content type="html"><![CDATA[<p>在做表情识别的时候，突然在《机器学习——算法原理与编程实践》一书中看到了人脸检测的部分。书中使用的是 OpenCV 自带的 Haar 特征级联表作为训练集，标记人脸的。这种方法我之前也在网上看到过，因为没有成功（现在看来应该是使用了错误的表造成的）所以使用了 face_recognition 的库来进行的。</p><p>现在既然成功完成了这种方法，那自然也要用起来。</p><hr><a id="more"></a><h1 id="前期配置"><a href="#前期配置" class="headerlink" title="前期配置"></a>前期配置</h1><p>这一次的表情识别的前期工作都是用 Python2.7 做的，因此代码也是基于 Python2.7 的。Python3 的话，应该也是大同小异的。</p><p>建议使用 anaconda 配置 Python 虚拟环境，使用起来也很方便。</p><p>需要使用的<a href="https://github.com/opencv/opencv/tree/master/data" target="_blank" rel="noopener">特征级联表</a>，书上使用 haarcascade_frontalface_alt_tree.xml 和 lbpcascade_frontalface.xml，我将使用后者。</p><p>上述两个文件分别在链接位置 haarcascades 和 lbpcascades 目录下。</p><hr><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">face_cascade = cv2.CascadeClassifier(<span class="string">'./lbpcascade_frontalface.xml'</span>)</span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># gray：传入的图片，一般使用灰度图</span></span><br><span class="line"><span class="comment"># 1.2： scaleFactor--表示在前后两次相继的扫描中，搜索窗口的比例系数。默认为1.1：即每次搜索窗口依次扩大10%</span></span><br><span class="line"><span class="comment"># 3：   minNeighbors--表示构成检测目标的相邻矩形的最小个数(默认为3个)。</span></span><br><span class="line"><span class="comment">#       如果组成检测目标的小矩形的个数和小于 min_neighbors - 1 都会被排除。</span></span><br><span class="line"><span class="comment">#       如果min_neighbors 为 0, 则函数不做任何操作就返回所有的被检候选矩形框，</span></span><br><span class="line"><span class="comment">#       这种设定值一般用在用户自定义对检测结果的组合程序上</span></span><br><span class="line">faces = face_cascade.detectMultiScale(gray, <span class="number">1.2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">face_cascade = cv2.CascadeClassifier(<span class="string">'./lbpcascade_frontalface.xml'</span>)</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'./test.jpg'</span>)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">faces = face_cascade.detectMultiScale(gray, <span class="number">1.2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">    img2 = cv2.rectangle(img, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">    cv2.imwrite(<span class="string">'./sample.jpg'</span>,img2)</span><br><span class="line">    <span class="comment"># 下面是面部区域的灰度图和原图，可以使用 imwrite 保存为文件</span></span><br><span class="line">    roi_gray = gray[y: y + h, x: x + w]</span><br><span class="line">    roi_color = img[y: y + h, x: x + w]</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'img'</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="/2018/02/24/Face-recog-with-opencv/sample.jpg" alt="sample"></p><hr><p>P.S. 在使用 dlib 做面部特征点标记的时候，发现 dlib 也有 face_detector，有时间我会在下一篇文章中介绍一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做表情识别的时候，突然在《机器学习——算法原理与编程实践》一书中看到了人脸检测的部分。书中使用的是 OpenCV 自带的 Haar 特征级联表作为训练集，标记人脸的。这种方法我之前也在网上看到过，因为没有成功（现在看来应该是使用了错误的表造成的）所以使用了 face_recognition 的库来进行的。&lt;/p&gt;
&lt;p&gt;现在既然成功完成了这种方法，那自然也要用起来。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://spectop.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://spectop.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="https://spectop.github.io/tags/Python/"/>
    
      <category term="人脸识别" scheme="https://spectop.github.io/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>Face Recognition的配置和初步使用</title>
    <link href="https://spectop.github.io/2018/01/19/Face-Recognition/"/>
    <id>https://spectop.github.io/2018/01/19/Face-Recognition/</id>
    <published>2018-01-19T02:54:27.000Z</published>
    <updated>2018-01-19T12:25:24.372Z</updated>
    
    <content type="html"><![CDATA[<p>由于新一届的物联网大赛有关于人脸识别的部分，因此老师让我给学弟学妹讲一讲有关人脸识别的部分。因为上次刷知乎的时候看到了一个圣诞节时的微信头像自动带圣诞帽的小程序用到了这个 face_recognition 的 Python 库，上网查了一下，发现离线识别率高达99.38%，因此就打算使用这个库了。</p><p>理想很丰满，现实很骨感。折腾了很长时间，不由得感叹，这个库是真 TMD 难配。</p><p>以下就是记录的一些过程吧！</p><hr><a id="more"></a><h1 id="配置和安装"><a href="#配置和安装" class="headerlink" title="配置和安装"></a>配置和安装</h1><p>需要的诸如 numpy、opencv 等的机器学习的常用库就不写了，这些不难，而且我早已配过了。重点是安装 dlib.</p><p>本次的配置基本参考<a href="https://github.com/ageitgey/face_recognition" target="_blank" rel="noopener">face_recognition的 readme</a></p><h2 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h2><ul><li>Python 3.3+ or Python 2.7</li><li>macOS or Linux (Windows not officially supported, but might work)</li></ul><p>这里我使用的环境就是 Python3.6 + macOS，（作者已经说了，Windows 环境下没有测试，而且我看了网上好像 Windows 确实各种坑，所以小伙伴们还是不要去跳坑了吧，老老实实 Linux 吧）</p><h2 id="安装-dlib"><a href="#安装-dlib" class="headerlink" title="安装 dlib"></a>安装 dlib</h2><p>作者有给连接指导怎样安装 dlib 的，<a href="https://gist.github.com/ageitgey/629d75c1baac34dfa5ca2a1928a7aeaf" target="_blank" rel="noopener">How to install dlib from source on macOS or Ubuntu</a>，但是这个网址被墙了，可以科学上网的同学就直接去看。</p><p>为了帮助无法科学上网的同学，我把 dlib 安装指导 copy 了过来：</p><blockquote><p>前置工作：</p><ul><li><p>For macOS</p><ul><li>安装 XCode （主要是 XCode command line utils）</li><li>安装 homebrew</li><li><code>brew install boost-python --with-python3 --without-python</code></li></ul></li><li><p>For Linux</p><ul><li><code>sudo apt-get install libboost-all-dev</code></li></ul></li></ul><p>安装：</p><ul><li>clone the code from github<br><code>git clone https://github.com/davisking/dlib.git</code></li><li>build the main dlib library<br><code>cd dlib</code><br><code>mkdir build; cd build; cmake .. -DDLIB_USE_CUDA=0 -DUSE_AVZ_INSTRUCTIONS=1; cmake --build</code></li><li>build and install the python extensions<br><code>cd ..</code><br><code>python3 setup.py install --yes USE_AVX_INSTRUCTIONS --no DLIB_USE_CUDA</code></li></ul></blockquote><h2 id="安装-face-recognition"><a href="#安装-face-recognition" class="headerlink" title="安装 face_recognition"></a>安装 face_recognition</h2><p>这个就没什么好说的了，<code>pip3 install face_recognition</code></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>如果你进入 Python3，可以成功 <code>import dlib</code> ，就表示你的 dlib 成功安装了<br>如果你在 terminal 内输入 <code>face_</code> ，按 tab 键，能够自动补全 face_recognition 说明 face_recognition 已经成功安装了</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>作者提供了一个 virtualBox 的 Ubuntu 镜像，内部已经配置好了一切的环境，如果有需要可以<a href="https://medium.com/@ageitgey/try-deep-learning-in-python-now-with-a-fully-pre-configured-vm-1d97d4c3e9b" target="_blank" rel="noopener">点这里</a>下载</p><h1 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h1><p>前面在 terminal 里面，face_recognition 就已经可以直接使用了，具体的做法是：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">face_recognition</span> 已知人物照片的目录 需要识别的照片目录</span><br></pre></td></tr></table></figure><p>还可以加入一些参数，比如容忍度 <code>--tolerance</code> ，越小的容忍度，则识别时就越严格</p><p>加入 <code>--show-distance true</code> 可以显示两个人脸的差距，用于调整容忍度</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>前面的是直接使用 <code>face_recognition</code> 这个命令的，当然也可以在 Python 里面 import 这个库，做其他的处理</p><p>我在使用库的时候遇到了 <code>No module named &#39;face_recognition&#39;</code> 的问题，如果你也遇到了这个问题，并且你确定你在输入 <code>pip3 list</code> 后，face_recognition 这个库确实已经安装完成了。那么你可以在代码中加入下面两句以引用 face_recognition</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"/usr/local/lib/python3.6/site-packages/"</span>)</span><br></pre></td></tr></table></figure><p>在添加了正确的路径之后，就可以正确的 import 这个包了（每个人的 site-packages 的位置不一定一样）</p><h2 id="面部定位"><a href="#面部定位" class="headerlink" title="面部定位"></a>面部定位</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image = face_recognition.load_image_file(<span class="string">"./pic/obm2.jpg"</span>)</span><br><span class="line">face_locations = face_recognition.face_locations(image)</span><br><span class="line">print(face_locations)</span><br></pre></td></tr></table></figure><p>首先使用 load_image_file 函数将需要识别的图片添加进去，再调用 face_locations 函数就可以返回面部的坐标，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="number">1268</span>, <span class="number">2884</span>, <span class="number">1423</span>, <span class="number">2729</span>), (<span class="number">1062</span>, <span class="number">2248</span>, <span class="number">1216</span>, <span class="number">2093</span>), (<span class="number">1142</span>, <span class="number">2575</span>, <span class="number">1271</span>, <span class="number">2446</span>), (<span class="number">1200</span>, <span class="number">1543</span>, <span class="number">1329</span>, <span class="number">1414</span>), (<span class="number">1295</span>, <span class="number">3111</span>, <span class="number">1481</span>, <span class="number">2925</span>), (<span class="number">1062</span>, <span class="number">2764</span>, <span class="number">1216</span>, <span class="number">2609</span>), (<span class="number">1027</span>, <span class="number">3482</span>, <span class="number">1212</span>, <span class="number">3296</span>), (<span class="number">1013</span>, <span class="number">1199</span>, <span class="number">1142</span>, <span class="number">1070</span>), (<span class="number">1148</span>, <span class="number">1336</span>, <span class="number">1302</span>, <span class="number">1182</span>), (<span class="number">1182</span>, <span class="number">1044</span>, <span class="number">1337</span>, <span class="number">889</span>), (<span class="number">956</span>, <span class="number">1629</span>, <span class="number">1085</span>, <span class="number">1500</span>), (<span class="number">1212</span>, <span class="number">778</span>, <span class="number">1398</span>, <span class="number">593</span>), (<span class="number">1062</span>, <span class="number">1869</span>, <span class="number">1216</span>, <span class="number">1715</span>), (<span class="number">956</span>, <span class="number">2532</span>, <span class="number">1085</span>, <span class="number">2403</span>), (<span class="number">1406</span>, <span class="number">3510</span>, <span class="number">1628</span>, <span class="number">3287</span>)]</span><br></pre></td></tr></table></figure><p>其中，每一个脸部位置坐标是由4个数字的元组组成的，其分别为 $ x_1 , y_1 , x_2 , y_2 $ ，这两个点分别是确定脸部位置的两角，可以用 OpenCV 加载图片，并且使用切片操作截取脸部</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (x1, y1, x2, y2) <span class="keyword">in</span> face_locations :</span><br><span class="line">    print(x1, x2, y1, y2)</span><br><span class="line">    f = img[x1 : x2, y2 : y1]</span><br><span class="line">    index = index + <span class="number">1</span></span><br><span class="line">    cv2.imwrite(<span class="string">"hezhao_"</span> + str(index) + <span class="string">".jpg"</span>, f)</span><br></pre></td></tr></table></figure><h2 id="面部比较"><a href="#面部比较" class="headerlink" title="面部比较"></a>面部比较</h2><ul><li>加载已知的头像</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dt_image = face_recognition.load_image_file(<span class="string">"./head/dt_1.jpg"</span>)</span><br><span class="line">sll_image = face_recognition.load_image_file(<span class="string">"./head/sll_1.jpg"</span>)</span><br><span class="line">obm_image = face_recognition.load_image_file(<span class="string">"./head/obm_1.jpg"</span>)</span><br></pre></td></tr></table></figure><ul><li>加载待识别的头像</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unknown_image_1 = face_recognition.load_image_file(<span class="string">"./unknow_head/unknow_1.jpg"</span>)</span><br></pre></td></tr></table></figure><ul><li>编码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dt_encoding = face_recognition.face_encodings(dt_image)[<span class="number">0</span>]</span><br><span class="line">sll_encoding = face_recognition.face_encodings(sll_image)[<span class="number">0</span>]</span><br><span class="line">obm_encoding = face_recognition.face_encodings(obm_image)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">unknown_encoding = face_recognition.face_encodings(unknown_image_1)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li>输入结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">results = face_recognition.compare_faces([dt_encoding, sll_encoding, obm_encoding], unknown_encoding[i])</span><br></pre></td></tr></table></figure><p>输出的结果是一个3个的 list，内部的值分别是 true 或者 false 表示是不是对应的人</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于新一届的物联网大赛有关于人脸识别的部分，因此老师让我给学弟学妹讲一讲有关人脸识别的部分。因为上次刷知乎的时候看到了一个圣诞节时的微信头像自动带圣诞帽的小程序用到了这个 face_recognition 的 Python 库，上网查了一下，发现离线识别率高达99.38%，因此就打算使用这个库了。&lt;/p&gt;
&lt;p&gt;理想很丰满，现实很骨感。折腾了很长时间，不由得感叹，这个库是真 TMD 难配。&lt;/p&gt;
&lt;p&gt;以下就是记录的一些过程吧！&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://spectop.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://spectop.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="https://spectop.github.io/tags/Python/"/>
    
      <category term="人脸识别" scheme="https://spectop.github.io/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://spectop.github.io/2017/02/11/hello-world/"/>
    <id>https://spectop.github.io/2017/02/11/hello-world/</id>
    <published>2017-02-11T10:55:06.000Z</published>
    <updated>2018-01-19T04:19:41.626Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>由于重装系统的缘故，Github也是很久都没有使用过了（并不是因为我懒得写代码  /手动滑稽）。</p><p>由于今天突然想使用Github和用Hexo写博客了，因此花了些时间把东西弄起来了（很坑的东西是我以前配置Hexo时参考的博客居然404了，因此又重新找了好久，我在考虑着是不是应该自己写一个教程，方便以后参考）</p><p>我之前是有个<strong>spectop1017</strong>的Github账号的，这是因为我当时学习使用Github时不太会，也不知道怎么的申请了两个账号，也不知道怎么的使用了<strong>spectop1017</strong>这个账号去提交代码了。那个账号里面也没有什么东西了，基本上都是当时学习Android时一些练手的程序，在<strong>spectop1017.github.io</strong>上面写的一些博客我也搬到<strong>spectop.github.io</strong>这里了，那个账号就不打算再使用了。另外我在一大堆文件中居然找到了当时因为重装系统而丢失的第一批Blog的Markdown文件，真是意外之喜，就一起搬运过来了。</p><p><em>分割线：以下是Hexo自带的Hello world文档</em></p><a id="more"></a><hr><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;由于重装系统的缘故，Github也是很久都没有使用过了（并不是因为我懒得写代码  /手动滑稽）。&lt;/p&gt;
&lt;p&gt;由于今天突然想使用Github和用Hexo写博客了，因此花了些时间把东西弄起来了（很坑的东西是我以前配置Hexo时参考的博客居然404了，因此又重新找了好久，我在考虑着是不是应该自己写一个教程，方便以后参考）&lt;/p&gt;
&lt;p&gt;我之前是有个&lt;strong&gt;spectop1017&lt;/strong&gt;的Github账号的，这是因为我当时学习使用Github时不太会，也不知道怎么的申请了两个账号，也不知道怎么的使用了&lt;strong&gt;spectop1017&lt;/strong&gt;这个账号去提交代码了。那个账号里面也没有什么东西了，基本上都是当时学习Android时一些练手的程序，在&lt;strong&gt;spectop1017.github.io&lt;/strong&gt;上面写的一些博客我也搬到&lt;strong&gt;spectop.github.io&lt;/strong&gt;这里了，那个账号就不打算再使用了。另外我在一大堆文件中居然找到了当时因为重装系统而丢失的第一批Blog的Markdown文件，真是意外之喜，就一起搬运过来了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;分割线：以下是Hexo自带的Hello world文档&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="杂项" scheme="https://spectop.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>markdown文档中mathjax的问题</title>
    <link href="https://spectop.github.io/2016/01/29/markdown%E6%96%87%E6%A1%A3%E4%B8%ADmathjax%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://spectop.github.io/2016/01/29/markdown文档中mathjax的问题/</id>
    <published>2016-01-28T16:03:10.000Z</published>
    <updated>2018-01-17T08:46:35.902Z</updated>
    
    <content type="html"><![CDATA[<p>在写markdown文档时经常会需要插入数学公式，我之前只会使用图片插入，上次在看到mathjax后，我开始了使用mathjax的历程，但在实际写文档的过程中遇到了一些问题。</p><a id="more"></a><h1 id="关于有一些公式无法正确的显示"><a href="#关于有一些公式无法正确的显示" class="headerlink" title="关于有一些公式无法正确的显示"></a>关于有一些公式无法正确的显示</h1><p>在写机器学习的文章中遇到的一个关于范数的公式写出来编辑器上显示没有问题，但是一旦放进文档里就不行了，这个问题困扰了我很长时间。</p><p>这是代码：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义</span><br><span class="line">&gt; <span class="formula">$$ <span class="tag">\<span class="name">lim</span></span>_&#123;k<span class="tag">\<span class="name">to</span></span><span class="tag">\<span class="name">infty</span></span>&#125;<span class="tag">\<span class="name">left</span></span>( <span class="tag">\<span class="name">sum</span></span>_&#123;i=1&#125;^n<span class="tag">\<span class="name">mid</span></span> p_i-q_i<span class="tag">\<span class="name">mid</span></span> ^k<span class="tag">\<span class="name">right</span></span>)^<span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;k&#125;</span></span> $$</span></span><br></pre></td></tr></table></figure></p><p>这是效果：</p><blockquote><p>严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义<br>$$ \lim<em>{k\to\infty}\left( \sum</em>{i=1}^n\mid p_i-q_i\mid ^k\right)^\frac{1}{k} $$</p></blockquote><p>这里haroopad显示的公式是正确的，但是hexo编译过后的网页显示就不对了。</p><p>把代码剪裁一下，看看什么样子的公式是可以的：<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义</span><br><span class="line">&gt; $$ <span class="symbol">\l</span>im_&#123;k<span class="symbol">\t</span>o<span class="symbol">\i</span>nfty&#125;<span class="symbol">\l</span>eft( <span class="symbol">\s</span>um_i <span class="symbol">\r</span>ight) $$</span><br></pre></td></tr></table></figure></p><p>效果：</p><blockquote><p>严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义<br>$$ \lim_{k\to\infty}\left( \sum_i \right) $$</p></blockquote><p>这个好像就可以，但是貌似sum后面的i一旦加上花括号就不行：<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义</span><br><span class="line">&gt; $$ <span class="symbol">\l</span>im_&#123;k<span class="symbol">\t</span>o<span class="symbol">\i</span>nfty&#125;<span class="symbol">\l</span>eft( <span class="symbol">\s</span>um_&#123;i&#125; <span class="symbol">\r</span>ight) $$</span><br></pre></td></tr></table></figure></p><p>效果：</p><blockquote><p>严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义<br>$$ \lim<em>{k\to\infty}\left( \sum</em>{i} \right) $$</p></blockquote><p>于是我点开了两个网页的源代码，定位到这一行：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义<span class="tag">&lt;<span class="name">br</span>&gt;</span>$$ \lim<span class="tag">&lt;<span class="name">em</span>&gt;</span>&#123;k\to\infty&#125;\left( \sum<span class="tag">&lt;/<span class="name">em</span>&gt;</span>&#123;i&#125; \right) $$<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义<span class="tag">&lt;<span class="name">br</span>&gt;</span>$$ \lim_&#123;k\to\infty&#125;\left( \sum_i \right) $$<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以发现最明显的不同就算lim后面的 <code>&lt;em&gt;</code>，这时我们注意到，hexo在编译的时候将lim和sum后面的下划线 _翻译成强调的 <code>&lt;em&gt;</code> 了，仔细观察前面的公式，确实可以发现一部分变成了斜体。所以我们要在所有的下划线 _ 前面加上 \ 转义就可以了。</p><p><strong>OK，搞定</strong></p><p><strong><em> p.s 我的chrome上显示的公式后面都有一个竖线，firefox没有，内啥，一般平时用chrome习惯，所以有人知道怎么弄咩？ </em></strong></p><p><strong><em> 上面的问题在重新配置Hexo之后就没有了，个人觉得应该是版本的问题？ </em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写markdown文档时经常会需要插入数学公式，我之前只会使用图片插入，上次在看到mathjax后，我开始了使用mathjax的历程，但在实际写文档的过程中遇到了一些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Markdown" scheme="https://spectop.github.io/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="https://spectop.github.io/tags/Markdown/"/>
    
      <category term="MathJax" scheme="https://spectop.github.io/tags/MathJax/"/>
    
  </entry>
  
  <entry>
    <title>「学习笔记」机器学习(1)</title>
    <link href="https://spectop.github.io/2016/01/22/%E3%80%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-1/"/>
    <id>https://spectop.github.io/2016/01/22/「学习笔记」机器学习-1/</id>
    <published>2016-01-22T06:32:57.000Z</published>
    <updated>2018-01-19T04:18:34.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="科学算法库的安装-linux"><a href="#科学算法库的安装-linux" class="headerlink" title="科学算法库的安装(linux)"></a>科学算法库的安装(linux)</h1><ul><li>1.安装Numpy<pre><code>sudo apt-get install python-numpy</code></pre></li><li>2.安装Scipy<pre><code>sudo apt-get install python-numpy</code></pre></li><li>3.Matplotlib<pre><code>sudo apt-get install tk-devsudo apt-get install python-gtk2-devsudo apt-get install python-pyside</code></pre></li><li>4.spyder GUI环境<pre><code>sudo apt-get install spyder</code></pre></li></ul><a id="more"></a><p><br></p><ul><li><p><strong>上述安装完毕后，可以利用</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>,<span class="number">4</span>*<span class="number">3.1415</span>,<span class="number">100</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line">plt.plot(x,y,label=<span class="string">"$sin(x)$"</span>,color=<span class="string">"red"</span>,linewidth=<span class="number">2</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><strong>进行测试。若生成正弦曲线窗口，则配置完成. </strong></p></li></ul><h1 id="NumPy的基本操作"><a href="#NumPy的基本操作" class="headerlink" title="NumPy的基本操作"></a>NumPy的基本操作</h1><ul><li><h2 id="Numpy-的导入"><a href="#Numpy-的导入" class="headerlink" title="Numpy 的导入"></a>Numpy 的导入</h2><pre><code>import numpy as np</code></pre><p>  这种写法在使用相关函数的时候需要写明是哪个包的，如:</p><pre><code>myZero = np.zeros([3,5])</code></pre><p>  还可以导入包全局使用</p><pre><code>from numpy import *</code></pre></li></ul><ul><li><h2 id="NumPy-的基本操作"><a href="#NumPy-的基本操作" class="headerlink" title="NumPy 的基本操作"></a>NumPy 的基本操作</h2><ol><li><p>创建全0矩阵和全1矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myZero = zeros([n,m])</span><br><span class="line">myOne = ones([n,m])</span><br></pre></td></tr></table></figure></li><li><p>生成随机矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myRand = random.rand(n,m)   <span class="comment"># n 行 m 列的 0～1 之间的随机数矩阵</span></span><br></pre></td></tr></table></figure></li><li><p>生成单位矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myEye = eye(n)   <span class="comment"># n * n 的单位阵</span></span><br></pre></td></tr></table></figure></li><li><p>将一个数组转化为一个矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myMatrix = mat([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br></pre></td></tr></table></figure></li><li><p>矩阵所有元素求和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S = sum(myMatrix)</span><br></pre></td></tr></table></figure></li><li><p>矩阵各元素的乘积</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix = multiply(matrix1, matrix2) <span class="comment"># matrix1 和 matrix2 对应元素相乘的矩阵</span></span><br></pre></td></tr></table></figure></li><li><p>求矩阵的 n 次幂</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix = power(myMatrix, n) <span class="comment">#生成一个矩阵，矩阵内部的元素是原矩阵对应元素的n次幂</span></span><br></pre></td></tr></table></figure></li><li><p>矩阵的转置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> matrix.T   <span class="comment">#打印转置后的矩阵，不改变原矩阵</span></span><br><span class="line">matrix.transpose()   <span class="comment">#同上</span></span><br></pre></td></tr></table></figure></li><li><p>矩阵的其他操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[m, n] = shape(matrix) <span class="comment"># m, n为矩阵的行列数</span></span><br><span class="line">myscl1 = matrix[<span class="number">0</span>] <span class="comment"># 矩阵的切片操作，取第一行</span></span><br><span class="line">myscl2 = matrix.T[<span class="number">0</span>] <span class="comment"># 矩阵的切片操作，取第一列</span></span><br><span class="line">mycpmat = matrix.copy() <span class="comment"># 矩阵的复制</span></span><br><span class="line"><span class="keyword">print</span> matrix1 &lt; matrix2 <span class="comment"># 矩阵的比较，会逐一比较对应的每一个元素，并输出一个仅包含True, False 的相同大小的矩阵</span></span><br><span class="line">dot(m1,m2)  <span class="comment">#计算m1,m2的点积</span></span><br><span class="line">norm(v)  <span class="comment">#计算向量V的范数</span></span><br></pre></td></tr></table></figure></li></ol></li><li><h2 id="Linalg线性代数库"><a href="#Linalg线性代数库" class="headerlink" title="Linalg线性代数库"></a>Linalg线性代数库</h2><ol><li><p>矩阵的行列式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> linalg.det(matrix)</span><br></pre></td></tr></table></figure></li><li><p>矩阵的逆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> linalg.inv(matrix)</span><br></pre></td></tr></table></figure></li><li><p>矩阵的对称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> matrix * matrix.T</span><br></pre></td></tr></table></figure></li><li><p>矩阵的秩</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> linalg.matrix_rank(A)</span><br></pre></td></tr></table></figure></li><li><p>可逆矩阵求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> linalg.solve(A,b.T) <span class="comment"># 如果b已经是一列的就不用转置了</span></span><br></pre></td></tr></table></figure></li></ol></li><li><h2 id="各类距离的python实现"><a href="#各类距离的python实现" class="headerlink" title="各类距离的python实现"></a>各类距离的python实现</h2><p>   <strong>各类距离会在后面说明</strong></p><ol><li><p>Euclidean Distance</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector1 = mat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">vector2 = mat([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="keyword">print</span> sqrt((vector1-vector2)*(vector1-vector2).T)</span><br></pre></td></tr></table></figure></li><li><p>Manhattan Distance</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector1 = mat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">vector2 = mat([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="keyword">print</span> sum(abs(vector1-vector2))</span><br></pre></td></tr></table></figure></li><li><p>Chebyshev Distance</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector1 = mat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">vector2 = mat([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="keyword">print</span> abs(vector1-vector2).max()</span><br></pre></td></tr></table></figure></li><li><p>Cosine</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cosV12 = dot(vector1,vector2)/(linalg.norm(vector1)*linalg.norm(vector2))</span><br><span class="line"><span class="keyword">print</span> cosV12</span><br></pre></td></tr></table></figure></li><li><p>Hamming Distance</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">matV = mat([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]])</span><br><span class="line">smstr = nonzero(matV[<span class="number">0</span>] - matV[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">print</span> shape(smstr[<span class="number">0</span>])[<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li><li><p>Jaccard Distance</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.spatial.distance <span class="keyword">as</span> dist</span><br><span class="line">matV = mat([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]])</span><br><span class="line"><span class="keyword">print</span> dist.pdist(matV, <span class="string">'jaccard'</span>)</span><br></pre></td></tr></table></figure></li></ol></li></ul><h1 id="机器学习的数学基础"><a href="#机器学习的数学基础" class="headerlink" title="机器学习的数学基础"></a>机器学习的数学基础</h1><ul><li><strong>范数</strong><blockquote><p>向量的范数可以简单、形象的理解为<strong>向量的长度</strong>，或者向量到坐标系原点的距离，或者<strong>相应空间内的两点之间的距离</strong></p><p><strong><em>向量的范数定义</em></strong> : 向量的范数是一个函数 $ \parallel x\parallel $ ,满足非负性 $ \parallel x\parallel &gt; 0 $ , 齐次性 $ \parallel cx\parallel = \mid c\mid\parallel x\parallel $ ,三角不等式 $ \parallel x+y\parallel \leq\parallel x\parallel +\parallel y\parallel $ 。</p><p>L1范数：  $\parallel x\parallel $为 $ x $向量各个元素绝对值之和。<br>L2范数：  $\parallel x\parallel $为 $ x $向量各个元素平方和的开方，又称 Euclidean 范数或者 Frobenius 范数。<br>Lp范数：  $\parallel x\parallel $为 $ x $向量各个元素绝对值 $ p $次方和的  $ 1\over p $ 次方<br>L $\infty $范数：  $\parallel x\parallel $为 $ x $向量各个元素绝对值最大的那个元素，如下：$$ \lim_{k\to\infty}\left( \sum_{i=1}^n\mid p_i-q_i\mid ^k\right)^\frac{1}{k}<br>$$</p></blockquote></li><li><strong>Minkowski Distance (闵可夫斯基距离)</strong><blockquote><p>严格意义上讲，Minkowski Distance 不是一种距离，而是一组距离的定义。<br>两个n维向量 $ A(x_{11},x_{12},\cdots,x_{1n}) $ 与 $ B(x_{21},x_{22},\cdots,x_{2n}) $ 间的Minkowski距离定义为：<br>$$ d_{12}=\sqrt[p]{\sum_{k=1}^n(x_{1k}-x_{2k})^p} $$<br>其中p是一个变参数。</p><ul><li>当 p=1 时，就是 Manhattan Distance (曼哈顿距离)</li><li>当 p=2 时，就是 Euclidean Distance (欧氏距离)</li><li>当 $ p\to\infty $ 时，就是 Chebyshev Distance (切比雪夫距离)</li></ul></blockquote></li><li><strong>Euclideam Distance</strong><blockquote><p>欧氏距离（L2范数）是最易于理解的一种距离计算方法，源于欧氏空间的两点距离公式<br>两个n维向量 $ A(x_{11},x_{12},\cdots,x_{1n}) $ 与 $ B(x_{21},x_{22},\cdots,x_{2n}) $ 之间的欧氏距离：<br>$$ d_{12}=\sqrt{\sum_{k=1}^n(x_{1k}-x_{2k})^2} $$<br>表示为向量运算的形式：<br>$$ d_{12}=\sqrt{(A - B)(A - B)^T} $$</p></blockquote></li><li><strong>Manhattan Distance</strong><blockquote><p>曼哈顿距离（L1范数）可以理解为计算网格中两点路径的距离<br>二维平面两点 $ A(x_1,y_1) $ 和 $ B(x_2,y_2) $ 间的曼哈顿距离:<br>$$ d_{12}=\mid x_1-x_2\mid +\mid y_1-y_2\mid $$<br>两个n维向量 $ A(x_{11},x_{12},\cdots,x_{1n}) $ 与 $ B(x_{21},x_{22},\cdots,x_{2n}) $ 之间的曼哈顿距离：<br>$$ d_{12}=\sum_{k=1}^n\mid x_{1k}-x_{2k}\mid $$</p></blockquote></li><li><strong>Chebyshev Distance</strong><blockquote><p>切比雪夫距离类似与棋盘上国王从一点到另一点移动的最少次数，即 $ max(\mid x_1-x_2\mid,\mid y_1-y_2\mid) $<br>两个n维向量 $ A(x_{11},x_{12},\cdots,x_{1n}) $ 与 $ B(x_{21},x_{22},\cdots,x_{2n}) $ 之间的切比雪夫距离：<br>$$ d_{12}=max_i(\mid x_{1i}-x_{2i}\mid) $$<br>该公式的另一个等价公式：<br>$$ d_{12}=\lim_{k\to\infty}\left(\sum_{i=1}^n\mid x_{1i}-x_{2i}\mid^k\right)^\frac{1}{k} $$</p></blockquote></li><li><strong>Cosine</strong><blockquote><p>夹角余弦可以用来两个向量方向的差异，机器学习中借用这一概念来衡量样本之间的差异<br>两个n维向量 $ A(x_{11},x_{12},\cdots,x_{1n}) $ 与 $ B(x_{21},x_{22},\cdots,x_{2n}) $ 之间的夹角余弦：<br>$$ \cos\theta=\frac{AB}{\mid A\mid\mid B\mid} $$<br>即：<br>$$ \cos\theta=\frac{\sum_{k=1}^nx_{1k}x_{2k}}{\sqrt{\sum_{k=1}^nx_{1k}^2}\sqrt{\sum_{k=1}^nx_{2k}^2}} $$</p></blockquote></li><li><strong>Hamming Distance</strong><blockquote><p>汉明距离的定义：两个等长字符串s1,s2,将其中一个变成另一个需要的最小替换次数。<br>应用：信息编码（为了增强容错性，应使得编码间的最小汉明距离尽可能大）</p></blockquote></li><li><strong>Jaccard Similarity Coefficient(杰卡德相似系数)</strong><blockquote><p>杰卡德相似系数：两个集合A,B的交集元素在并集元素中所占的比例，用符号 $ J(A,B) $ 表示<br>$$ J(A,B)=\frac{\mid A\cap B\mid}{\mid A\cup B\mid} $$<br>杰卡德距：与杰卡德相似系数相反的概念：<br>$$ J_\delta(A,B)=1-J(A,B)=\frac{\mid A\cup B\mid-\mid A\cap B\mid}{\mid A\cup B\mid} $$</p></blockquote></li><li><p><strong>特征间的相关性</strong></p><blockquote><ol><li><p>相关系数与相关距离<br> 相关系数：<br> $$ \rho_{XY}=\frac{Cov(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}=\frac{E((X-EX)(Y-EY))}{\sqrt{D(X)}\sqrt{D(Y)}} $$<br> 相关距离：<br> $$ D_{XY}=1-\rho_{XY} $$<br>python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">featuremat = mat(...)  <span class="comment"># 初始化矩阵</span></span><br><span class="line"><span class="comment"># 计算均值</span></span><br><span class="line">mv1 = mean(featuremat[<span class="number">0</span>])  <span class="comment"># 计算第一列的均值</span></span><br><span class="line">mv2 = mean(featuremat[<span class="number">1</span>])  <span class="comment"># 计算第二列的均值</span></span><br><span class="line"><span class="comment">#计算两列的标准差</span></span><br><span class="line">dv1 = std(featuremat[<span class="number">0</span>]) </span><br><span class="line">dv2 = std(featuremat[<span class="number">1</span>])</span><br><span class="line">corref = mean(multiply(featuremat[<span class="number">0</span>]-mv1,featuremat[<span class="number">1</span>]-mv2))/(dv1*dv2)</span><br><span class="line"><span class="keyword">print</span> corref  <span class="comment">#输出相关系数</span></span><br><span class="line"><span class="keyword">print</span> corrcoef(featuremat)  <span class="comment">#输出相关系数矩阵</span></span><br></pre></td></tr></table></figure></li><li><p>马氏距离</p></li></ol></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;科学算法库的安装-linux&quot;&gt;&lt;a href=&quot;#科学算法库的安装-linux&quot; class=&quot;headerlink&quot; title=&quot;科学算法库的安装(linux)&quot;&gt;&lt;/a&gt;科学算法库的安装(linux)&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.安装Numpy&lt;pre&gt;&lt;code&gt;sudo apt-get install python-numpy
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;2.安装Scipy&lt;pre&gt;&lt;code&gt;sudo apt-get install python-numpy
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;3.Matplotlib&lt;pre&gt;&lt;code&gt;sudo apt-get install tk-dev
sudo apt-get install python-gtk2-dev
sudo apt-get install python-pyside
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;4.spyder GUI环境&lt;pre&gt;&lt;code&gt;sudo apt-get install spyder
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://spectop.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://spectop.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="https://spectop.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title> 重写博客</title>
    <link href="https://spectop.github.io/2016/01/22/%E9%87%8D%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>https://spectop.github.io/2016/01/22/重写博客/</id>
    <published>2016-01-22T05:58:07.000Z</published>
    <updated>2018-01-17T08:46:35.902Z</updated>
    
    <content type="html"><![CDATA[<p>一件很不幸的事，我重装系统的时候好像忘了把hexo的文章备份下来，结果那些markdown文档就都呵呵了 TAT～</p><p>重新配置了一次hexo真的好麻烦，搞了半天，我真不知道我当时是怎么弄好的！</p><p>之前的那些文章我还没有md文档，不过我倒是把整个博客给clone下来保存好了，以后如果有时间还是会恢复的吧。</p><p>这么快就放假了，然而真心觉得2015有点对不起自己，对不起这一年的时间。不过怎么说呢，后悔是没有用的，毕竟人要往前看嘛。只是希望2016结束的时候我不要还是这样，还是说出同样的话。</p><p><strong> 再不努力就老了！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一件很不幸的事，我重装系统的时候好像忘了把hexo的文章备份下来，结果那些markdown文档就都呵呵了 TAT～&lt;/p&gt;
&lt;p&gt;重新配置了一次hexo真的好麻烦，搞了半天，我真不知道我当时是怎么弄好的！&lt;/p&gt;
&lt;p&gt;之前的那些文章我还没有md文档，不过我倒是把整个博客给
      
    
    </summary>
    
      <category term="杂项" scheme="https://spectop.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>背包九讲</title>
    <link href="https://spectop.github.io/2015/07/21/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"/>
    <id>https://spectop.github.io/2015/07/21/背包九讲/</id>
    <published>2015-07-21T13:25:48.000Z</published>
    <updated>2018-01-17T08:46:35.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0/1背包问题"></a>0/1背包问题</h1><blockquote><p>有N件物品和一个容量为V的背包。放入第i件物品耗费的空间是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大？</p></blockquote><p>  将每一件物品从1到n编号，从第1件物品开始，每一件物品就只有两个状态：放进背包了 / 没有放进背包。</p><p>  我们画一张表格，行对应着每一件物品，列对应着背包的重量，那么pack[i][j]就表示  <strong>前i件物品，背包最大承重j</strong> 这个子问题的解。</p><p> 给一组数据作为样例：</p><pre><code>5 106 23 25 64 56 4</code></pre><p>  第一行表示有5件物品，10为最大承重，2-6行为5个物品的价值和重量。</p><p><strong>生成以下的表格</strong></p><pre><code>0    6    6    6    6     6     6     6     6     60    6    6    9    9     9     9     9     9     90    6    6    9    9     9     9    11    11    140    6    6    9    9     9    10    11    13    140    6    6    9    9    12    12    15    15    15</code></pre><p>　所以最终的结果是最后一行最后一列的 <strong>15</strong></p><p><strong>给出代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 01 package problem */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pack[<span class="number">100</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">100</span>],w[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(pack,<span class="number">0</span>,<span class="keyword">sizeof</span>(pack));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= r; j++)</span><br><span class="line">            pack[i][j] = max(pack[i - <span class="number">1</span>][j - c[i]] + w[i], pack[i - <span class="number">1</span>][j]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pack[n][r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,V;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123; <span class="comment">//多组数据</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;V;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;c[i]&gt;&gt;w[i];</span><br><span class="line">        make(n,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码优化</strong></p><p>这个代码在时间上应该已经不能再优化了，但是还可以考虑空间复杂度的优化。</p><p><strong>优化的基本思路：</strong></p><p>考虑所用到的状态转移方程: <code>pack[i][j] = max(pack[i-1][j-c[i]] + w[i], pack[i-1][j]);</code> 可以发现 <code>pack[i][j]</code> 的值并不和整个二维表的每一个数字的值都有关，而是仅仅和上面一行的值有关，所以可以使用 <code>pack[2][n]</code> 这么大的数组来存储结果。</p><p>考虑状态转移方程的实际情况，还可以使用<strong>一维数组</strong>来进行运算，但是要注意的是，此时，循环应该从后往前进行。因为如果是按从前往后的顺序，那么 <code>pack[i][j] = max(pack[i][j-c[i]] + w[i] , pack[i][j]);</code> 中进行比较的两个值 <code>pack[i][j]</code> 是没有更新的，也就是 <code>pack[i-1][j]</code> 的值，而 <code>pack[i][j - c[i]]</code>一定是前面被更新过的，也就是 <code>pack[i][j-w[i]]</code> 的值。这就是说，<code>max()</code> 比较的两个数是属于原来二维数组中不同的两行，而不是我们期望的相同的两行。</p><p>如果上面的说法不能理解我们不妨这样：有一件物品的性价比很高，在pack数组的某个位置，我们第一次将这个物品放入背包中，但是按照从前往后的顺序，很可能在这个位置的后面某个位置我们会<strong><em>再次</em></strong>将这个物品添加进去。</p><p><strong>优化后的代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pack[<span class="number">10000</span>],c[<span class="number">1000</span>],w[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pack,<span class="number">0</span>,<span class="keyword">sizeof</span>(pack));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = r; j &gt;= w[i]; j--)</span><br><span class="line">            pack[j] = max(pack[j], pack[j - c[i]] + w[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pack[r]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,t,V;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;V;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span>&gt;&gt;c[i]&gt;&gt;w[i];</span><br><span class="line">        make(n,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化问题：</strong></p><blockquote><ul><li><p>如果限定背包必须装满，那么需要将数组初始化为 -∞ （负无穷大）</p></li><li><p>如果背包可以不装满，那么数组初始化为0</p></li></ul></blockquote><p><em>为了后面的书写方便，我们把代码改成这样</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOnePack</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = V; i &gt;= c; i--)</span><br><span class="line">pack[i] = max(pack[i], pack[i - c] + w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>这样01背包问题的主要代码就是这样：</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">ZeroOnePack(c[i],w[i]);</span><br></pre></td></tr></table></figure><p>这样ZeroOnePack()这个函数就专门解决了<strong>“放一个物品”</strong>的问题</p><h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><blockquote><p>完全背包问题和0/1背包问题几乎一模一样，不同的就是物品不再是一个，而是无数个</p></blockquote><p><strong>思路</strong></p><p>完全背包不同处是原来的一个物品变成了无数个，但是我们还是可以把它变成0/1背包问题的，试想一下，即使拥有无数个物品，但是真的可以用无数个吗？</p><p>不可能，因为背包的容量有限，所以每个物品c,w<strong>最多可以使用[V/c]个</strong>，所以以下面的数据为例：</p><pre><code>c:    3    2    5    4w:    7    4    2    5V = 10</code></pre><p>我们完全可以把这组数据改成这样：</p><pre><code>c:    3    3    3    2    2    2    2    2    5    5    4    4w:    7    7    7    4    4    4    4    4    2    2    5    5</code></pre><p>原因自然是背包容量最大为10,所以占用空间为3的物品最多放3个，修改过后的数据就可以用0/1背包的方法处理</p><p>那难道完全背包需要重开一个c2[],w2[]，然后按0/1背包处理吗？</p><p>当然不是，还记得我们将0/1背包进行优化时说的如果循环从前向后进行会发生什么后果吗？</p><p>这一句 <strong>“但是按照从前往后的顺序，很可能在这个位置的后面某个位置我们会再次将这个物品添加进去。”</strong></p><p>看到了？0/1背包时为了避免重复，我们将循环改为从后往前，但是完全背包是可以重复使用物品的，对吧？所以代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePack</span><span class="params">(c,w)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = c; i &lt;= V; i++)</span><br><span class="line">pack[i] = max(pack[i],pack[i - c] + w )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么样，和0/1背包只有一点点的差别对不对？</p><h1 id="3-多重背包问题"><a href="#3-多重背包问题" class="headerlink" title="3.多重背包问题"></a>3.多重背包问题</h1><blockquote><p>多重背包和0/1背包不同的地方就是物品不是一个而是有m个</p></blockquote><p>所以我们还是就一个物品c,w,m分析：</p><p>对于m可能有两种情况：</p><ol><li><code>m &gt;= [V/c]</code>，这种情况明显是完全背包</li><li><code>0 &lt; m &lt; [v/c]</code>，对于这种情况需要认真分析一下</li></ol><p>我们仍然需要按照0/1背包的思路把这些物品拆开，而且我们要保证我们拆出来的这些物品可以通过组合表示出1到m任意件物。</p><p>我们可以考虑二进制的计数方法，这样我们把物品拆成<code>(c,w) , (2c,2w) , (4c,4w) …… [(m-2^k)*c , (m-2^k)*w)]</code></p><p>不管最优解会在这件物品中取几件，我们都可以用我们拆出来的这些物品来表示（请自己证明，二进制的思想）</p><p>所以，有了思路，代码就简单了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MultiplePack</span><span class="params">(c,w,m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (c * m &gt;= V) &#123;</span><br><span class="line">CompletePack(c,w);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (k &lt; m) &#123;</span><br><span class="line">ZeroOnePack(c*k,w*k);</span><br><span class="line">m = m - k;</span><br><span class="line">k = <span class="number">2</span> * k;</span><br><span class="line">&#125;</span><br><span class="line">ZeroOnePack(c * m, w * m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>其实就是0/1背包和完全背包的组合，有木有？</em></strong></p><p>未完待续……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-1背包问题&quot;&gt;&lt;a href=&quot;#0-1背包问题&quot; class=&quot;headerlink&quot; title=&quot;0/1背包问题&quot;&gt;&lt;/a&gt;0/1背包问题&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;有N件物品和一个容量为V的背包。放入第i件物品耗费的空间是Ci，得到的价值
      
    
    </summary>
    
      <category term="算法" scheme="https://spectop.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C/C++" scheme="https://spectop.github.io/tags/C-C/"/>
    
      <category term="背包问题" scheme="https://spectop.github.io/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
      <category term="算法" scheme="https://spectop.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux下如何实现C语言的system(&quot;pause&quot;)</title>
    <link href="https://spectop.github.io/2015/04/15/Linux%E4%B8%8B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0C%E8%AF%AD%E8%A8%80%E7%9A%84system-pause/"/>
    <id>https://spectop.github.io/2015/04/15/Linux下如何实现C语言的system-pause/</id>
    <published>2015-04-15T01:23:57.000Z</published>
    <updated>2018-01-19T04:19:57.532Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><strong>getch()</strong> ?</p><ul><li>不是标准库中的函数，在Linux中一般情况无法使用</li></ul></li><li><p><strong>getchar() + printf(“\b”)</strong> ?</p><ul><li><p>貌似使用getchar()读入，再输出一个退格符将原来回显的字符删除应该是可以的，但是在实际试了一下发现根本不行。。。</p></li><li><p><strong>原因</strong>：终端驱动器确实会读一个字符，但是他的输入只有到’\n’ 或 EOF 才会结束，所以如果不输入回车就不会实际执行getchar().    当然，如果上一次输入的字符并没有全部读完是可以getchar()把没有读完的字符读掉。</p></li></ul></li></ul><a id="more"></a><ul><li><strong><em>解决办法</em></strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">system_pause</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">getchar();</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">"Press any key to continue..."</span>);</span><br><span class="line"> system(<span class="string">"stty raw"</span>);</span><br><span class="line"> getchar();</span><br><span class="line">system(<span class="string">"stty cooked"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\b"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这段代码也是我在网上找到的，我的理解是：</p><ul><li>getchar()读掉上面多余的’\n’，按程序的实际情况添加</li><li>输出”Press any key to continue…”</li><li>system(“stty raw”);：将终端驱动器改为一次一个字符的模式，即输入一个字符就结束输入</li><li>getchar(); 读一个字符</li><li>system(“stty cooked”); 将终端驱动器改回一次一行的模式</li><li>printf(‘\b’); 退格，将回显的字符删除</li></ul><hr><p>p.s. 以上仅仅是个人理解，欢迎大家指出其中的错误</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;getch()&lt;/strong&gt; ?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不是标准库中的函数，在Linux中一般情况无法使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;getchar() + printf(“\b”)&lt;/strong&gt; ?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;貌似使用getchar()读入，再输出一个退格符将原来回显的字符删除应该是可以的，但是在实际试了一下发现根本不行。。。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;原因&lt;/strong&gt;：终端驱动器确实会读一个字符，但是他的输入只有到’\n’ 或 EOF 才会结束，所以如果不输入回车就不会实际执行getchar().    当然，如果上一次输入的字符并没有全部读完是可以getchar()把没有读完的字符读掉。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://spectop.github.io/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://spectop.github.io/tags/C-C/"/>
    
      <category term="Linux" scheme="https://spectop.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C/C++的一些有趣的区别</title>
    <link href="https://spectop.github.io/2015/03/17/C-C++%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://spectop.github.io/2015/03/17/C-C++的一些有趣的区别/</id>
    <published>2015-03-17T14:55:06.000Z</published>
    <updated>2018-01-19T04:19:26.928Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://www.geeksforgeeks.org" target="_blank" rel="noopener">geeksforgeeks</a>上看到一篇文章，说的是一些在C中可以编译但在C++中不行的程序，觉得比较好玩，就翻译分享一下啦。</p><hr><ul><li>在C++中，在main()中使用其它自定义的函数时必须在前面写上声明或者定义，但是在C中却可以写在main()的后面</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   foo(); <span class="comment">// foo() is called before its declaration/definition</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Hello"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序在C中可以编译成功，但是在C++中就不行</p><a id="more"></a><hr><ul><li>在C++中，指针是不能指向一个常量的，但是在C中可以</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> j = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* The below assignment is invalid in C++, results in error</span></span><br><span class="line"><span class="comment">       In C, the compiler may throw a warning, but casting is</span></span><br><span class="line"><span class="comment">       implicitly allowed */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *ptr = &amp;j;  <span class="comment">// A normal pointer points to const</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*ptr: %d\n"</span>, *ptr);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>在C语言中，一个空指针可以直接指派给其他指针，如int<em>，char </em>。但在C中，必须指定类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">void</span> *vptr;</span><br><span class="line">   <span class="keyword">int</span> *iptr = vptr; <span class="comment">//In C++, it must be replaced with int *iptr=(int *)vptr; </span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>下面的程序在C中可以编译，但是在C++中不行，必须为常量初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;   <span class="comment">// LINE 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Line 4 [Error] uninitialized const ‘a’ [-fpermissive]</p></blockquote><hr><ul><li>在C中可以用C++的一些特定的关键字作为变量名</li></ul><p><em>p.s. 这是自然，汗</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">new</span> = <span class="number">5</span>;  <span class="comment">// new is a keyword in C++, but not in C</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>C++的检查会比C更严格，如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *c = <span class="number">333</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c = %u"</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>error “invalid conversion from ‘int’ to ‘char*’”.</p></blockquote><hr><p><strong>试了一些，确实是这样，感觉蛮有趣的！</strong></p><p><a href="http://www.geeksforgeeks.org/write-c-program-wont-compiler-c/" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://www.geeksforgeeks.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;geeksforgeeks&lt;/a&gt;上看到一篇文章，说的是一些在C中可以编译但在C++中不行的程序，觉得比较好玩，就翻译分享一下啦。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;在C++中，在main()中使用其它自定义的函数时必须在前面写上声明或者定义，但是在C中却可以写在main()的后面&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   foo(); &lt;span class=&quot;comment&quot;&gt;// foo() is called before its declaration/definition&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的程序在C中可以编译成功，但是在C++中就不行&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://spectop.github.io/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://spectop.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://spectop.github.io/2015/03/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://spectop.github.io/2015/03/15/我的第一篇博客/</id>
    <published>2015-03-15T07:06:48.000Z</published>
    <updated>2018-01-17T08:46:35.903Z</updated>
    
    <content type="html"><![CDATA[<p>为了搞这个博客我确实花了不少功夫，从昨天晚上12点左右就开始了，看教程啊，然后自己操作去搞。加上一些教程由于时间的问题，总是存在着一些坑要填。不过麻烦归麻烦，我也总算是在3点的时候把东西推到github上面去了。</p><p>今天在申请免费的一级域名，免费的太难找到了，找到的又都是坑。反正这段时间域名解析什么的就慢慢来吧，不着急。</p><p>以前没有认真看markdown，只是能把每次的东西更新到tower上就满足了。现在还是认真看看markdown吧，毕竟写就要认真写。</p><blockquote><ul><li>p.s. 附上一个大坑，也提醒一下我自己<br><strong>一定记住冒号后面留一个空格</strong></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了搞这个博客我确实花了不少功夫，从昨天晚上12点左右就开始了，看教程啊，然后自己操作去搞。加上一些教程由于时间的问题，总是存在着一些坑要填。不过麻烦归麻烦，我也总算是在3点的时候把东西推到github上面去了。&lt;/p&gt;
&lt;p&gt;今天在申请免费的一级域名，免费的太难找到了，找
      
    
    </summary>
    
      <category term="杂项" scheme="https://spectop.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
</feed>
